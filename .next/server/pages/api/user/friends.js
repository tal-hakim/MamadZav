"use strict";(()=>{var e={};e.id=361,e.ids=[361],e.modules={1185:e=>{e.exports=require("mongoose")},145:e=>{e.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},6249:(e,r)=>{Object.defineProperty(r,"l",{enumerable:!0,get:function(){return function e(r,n){return n in r?r[n]:"then"in r&&"function"==typeof r.then?r.then(r=>e(r,n)):"function"==typeof r&&"default"===n?r:void 0}}})},6651:(e,r,n)=>{n.r(r),n.d(r,{config:()=>_,default:()=>S,routeModule:()=>j});var o={};n.r(o),n.d(o,{default:()=>q});var s=n(1802),t=n(7153),i=n(6249),a=n(2250),d=n(8208),u=n(6864);let l=require("fs");var c=n.n(l);let f=require("path");var m=n.n(f);let g=m().join(process.cwd(),"logs"),p=m().join(g,"app.log");function h(e,r,n){let o=new Date().toISOString(),s=n?`
${JSON.stringify(n,null,2)}`:"";return`[${o}] ${e}: ${r}${s}
`}c().existsSync(g)||c().mkdirSync(g,{recursive:!0});let y={info:(e,r)=>{let n=h("INFO",e,r);c().appendFileSync(p,n),console.log(e,r||"")},error:(e,r)=>{let n=h("ERROR",e,r);c().appendFileSync(p,n),console.error(e,r||"")},debug:(e,r)=>{let n=h("DEBUG",e,r);c().appendFileSync(p,n),console.log(e,r||"")}};async function w(e,r){if(console.log("Friends API called with method:",e.method),!["GET","POST","DELETE","PUT","PATCH"].includes(e.method||""))return r.status(405).json({message:"Method not allowed"});try{try{console.log("Attempting to connect to MongoDB..."),await (0,a.Z)(),console.log("Successfully connected to MongoDB")}catch(e){return console.error("Database connection error:",e),r.status(500).json({message:"Database connection failed",error:e instanceof Error?e.message:"Unknown error"})}if(!e.user)return console.log("No user found in request"),r.status(401).json({message:"Not authenticated"});console.log("User found in request:",e.user._id);let n=e.user;if("GET"===e.method)try{if(console.log("Looking up user:",n._id),!await d.n.findById(n._id))return console.error("User not found in database:",n._id),r.status(404).json({message:"User not found"});console.log("Found user in database"),console.log("Populating user data...");let e=await d.n.findById(n._id).populate({path:"friends",select:"name email username lastCheckIn"}).populate({path:"friendRequests.from",select:"name email username"}).select("friends friendRequests").lean();if(!e)return console.error("Failed to populate user data:",n._id),r.status(500).json({message:"Failed to fetch user data"});console.log("Successfully populated user data"),console.log("Raw friends data:",e.friends);let o=(e.friends||[]).filter(e=>e&&e._id).map(e=>({id:e._id.toString(),name:e.name,username:e.username,email:e.email,lastCheckIn:e.lastCheckIn}));console.log("Processed friends:",o.length),console.log("Raw friend requests data:",e.friendRequests);let s=(e.friendRequests||[]).filter(e=>e&&e.from&&e.from._id).map(e=>({id:e.from._id.toString(),name:e.from.name,username:e.from.username||"",email:e.from.email,createdAt:e.createdAt}));return console.log("Processed friend requests:",s.length),r.status(200).json({friends:o,friendRequests:s})}catch(e){return console.error("Error fetching friends and requests:",e),r.status(500).json({message:"Error fetching friends and requests",error:e instanceof Error?e.message:"Unknown error"})}let{username:o}=e.body;if(!o)return r.status(400).json({message:"Username is required"});if("POST"===e.method)try{let e=await d.n.findOne({username:o.toLowerCase()});if(!e)return r.status(404).json({message:"User not found"});if(e._id.toString()===n._id.toString())return r.status(400).json({message:"Cannot add yourself as a friend"});if(n.friends.some(r=>r.toString()===e._id.toString()))return r.status(400).json({message:"Already friends"});if(e.friendRequests.find(e=>e.from.toString()===n._id.toString()))return r.status(400).json({message:"Friend request already sent"});if(n.friendRequests.find(r=>r.from.toString()===e._id.toString()))return r.status(400).json({message:"This user has already sent you a friend request. Check your friend requests to accept it."});return await d.n.findByIdAndUpdate(e._id,{$push:{friendRequests:{from:n._id,createdAt:new Date}}},{new:!0}),r.status(200).json({message:"Friend request sent successfully"})}catch(e){return console.error("Error sending friend request:",e),r.status(500).json({message:"Error sending friend request"})}if("PUT"===e.method)try{if(y.info("=== START: Friend Request Acceptance ==="),y.debug("Request body:",e.body),y.debug("Username from request:",o),y.debug("Current user:",{id:n._id,username:n.username}),!o)return y.error("No username provided in request"),r.status(400).json({message:"Username is required"});y.debug("Fetching current user with populated data...");let s=await d.n.findById(n._id).populate({path:"friendRequests.from",select:"name email username"}).exec();if(!s)return y.error("Could not find current user with populated data"),r.status(500).json({message:"Error loading user data"});let t=await d.n.findOne({username:o.toLowerCase()});if(!t)return y.error("Friend not found with username:",o),r.status(404).json({message:"User not found"});y.debug("Looking for friend request...");let i=s.friendRequests.find(e=>e.from._id.toString()===t._id.toString());if(!i)return y.error("No friend request found for user:",{friendId:t._id,username:t.username,availableRequests:s.friendRequests.map(e=>({id:e.from._id,username:e.from.username}))}),r.status(400).json({message:"No friend request found from this user",debug:{requestedUsername:o,availableRequests:s.friendRequests.map(e=>e.from.username)}});y.debug("Found pending request:",{from:{id:i.from._id,username:t.username}}),y.info("Updating both users...");try{let[e]=await Promise.all([d.n.findByIdAndUpdate(s._id,{$push:{friends:t._id},$pull:{friendRequests:{from:t._id}}},{new:!0}).exec(),d.n.findByIdAndUpdate(t._id,{$push:{friends:s._id}},{new:!0}).exec()]);return y.info("Updates successful"),y.debug("Updated user friends:",e?.friends),r.status(200).json({message:"Friend request accepted successfully",friend:{id:t._id,name:t.name,username:t.username,email:t.email}})}catch(e){throw y.error("Error during user updates:",e),e}}catch(e){return y.error("Error accepting friend request:",e),r.status(500).json({message:"Error accepting friend request",error:e instanceof Error?e.message:"Unknown error"})}if("DELETE"===e.method)try{let o;y.info("=== START: Friend Removal/Rejection ==="),y.debug("Request body:",e.body);let{username:s,userId:t}=e.body;if(!s&&!t)return y.error("No username or userId provided"),r.status(400).json({message:"Username or userId is required"});y.debug("Fetching current user with populated data...");let i=await d.n.findById(n._id).populate({path:"friendRequests.from",select:"name email username"}).populate("friends").exec();if(!i)return y.error("Could not find current user with populated data"),r.status(500).json({message:"Error loading user data"});let a=i.friends.find(e=>e._id.toString()===t||e.username===s);if(a)return y.info("Removing friend:",a),await Promise.all([d.n.findByIdAndUpdate(i._id,{$pull:{friends:a._id}},{new:!0}),d.n.findByIdAndUpdate(a._id,{$pull:{friends:i._id}},{new:!0})]),y.info("Friend removed successfully"),r.status(200).json({message:"Friend removed successfully"});if(!(o=t?i.friendRequests.find(e=>e.from._id.toString()===t):i.friendRequests.find(e=>e.from.username?.toLowerCase()===s.toLowerCase())))return y.error("No friend request found to reject:",{username:s,userId:t}),r.status(400).json({message:"No friend request found from this user"});return y.debug("Found request to remove:",{from:{id:o.from._id,name:o.from.name,email:o.from.email}}),await d.n.findByIdAndUpdate(i._id,{$pull:{friendRequests:{from:o.from._id}}},{new:!0}),y.info("Friend request rejected successfully"),r.status(200).json({message:"Friend request rejected"})}catch(e){return y.error("Error in friend removal/rejection:",e),r.status(500).json({message:"Error processing friend removal/rejection"})}if("PATCH"===e.method)try{y.info("=== START: User Update ===");let e=await d.n.findByIdAndUpdate("684ebc174ef1c1e06472b747",{$set:{username:"lilo_stitch"}},{new:!0});if(!e)return y.error("Could not find lilo's user record"),r.status(404).json({message:"User not found"});return y.info("Successfully updated lilo's username"),r.status(200).json({message:"Username updated successfully",user:{id:e._id,name:e.name,username:e.username,email:e.email}})}catch(e){return y.error("Error updating user:",e),r.status(500).json({message:"Error updating user"})}}catch(e){return console.error("Friends operation error:",e),r.status(500).json({message:"Error processing friends operation"})}}function q(e,r){return(0,u.l)(e,r,()=>w(e,r))}let S=(0,i.l)(o,"default"),_=(0,i.l)(o,"config"),j=new s.PagesAPIRouteModule({definition:{kind:t.x.PAGES_API,page:"/api/user/friends",pathname:"/api/user/friends",bundlePath:"",filename:""},userland:o})},2250:(e,r,n)=>{n.d(r,{Z:()=>a});var o=n(1185),s=n.n(o);let t=process.env.MONGODB_URI;if(!t)throw Error("Please define the MONGODB_URI environment variable inside .env.local");let i=global.mongoose||{conn:null,promise:null};global.mongoose||(global.mongoose=i);let a=async function(){if(i.conn){if(1===s().connection.readyState)return console.log("Using cached database connection"),i.conn;console.log("Cached connection is no longer valid, creating new connection..."),i.conn=null,i.promise=null}if(i.promise)console.log("Using existing connection promise");else try{console.log("Creating new database connection...");let e=s();i.promise=s().connect(t,{bufferCommands:!1,serverSelectionTimeoutMS:1e4,socketTimeoutMS:45e3,family:4,maxPoolSize:10,minPoolSize:1,connectTimeoutMS:1e4,retryWrites:!0,retryReads:!0}).then(()=>(console.log("MongoDB connected successfully"),s().connection.on("error",e=>{console.error("MongoDB connection error:",e),1!==s().connection.readyState&&(i.conn=null,i.promise=null)}),s().connection.on("disconnected",()=>{console.warn("MongoDB disconnected"),1!==s().connection.readyState&&(i.conn=null,i.promise=null)}),s().connection.on("connected",()=>{console.log("MongoDB connected")}),s().connection.on("reconnected",()=>{console.log("MongoDB reconnected"),i.conn=e}),e))}catch(e){throw console.error("Error creating MongoDB connection:",e),i.promise=null,e}try{let e;console.log("Waiting for connection to be established...");let r=0;for(;r<3;)try{return i.conn=await i.promise,console.log("Connection established successfully"),i.conn}catch(n){e=n,r++,console.error(`Failed to establish connection (attempt ${r}/3):`,n),r<3&&(console.log(`Retrying in ${2*r} seconds...`),await new Promise(e=>setTimeout(e,2e3*r)),i.promise=null)}throw console.error("Max retries reached, could not establish connection"),e}catch(e){throw console.error("Error establishing MongoDB connection:",e),i.promise=null,e}}},6864:(e,r,n)=>{n.d(r,{l:()=>a,R:()=>d});let o=require("jsonwebtoken");var s=n.n(o),t=n(8208);if(!process.env.JWT_SECRET)throw Error("Please define the JWT_SECRET environment variable inside .env.local");let i=process.env.JWT_SECRET;async function a(e,r,n){try{let o;console.log("\n=== START: Auth Middleware ==="),console.log("Method:",e.method),console.log("Path:",e.url);let a=e.headers.authorization;if(!a?.startsWith("Bearer "))return console.log("No token provided"),r.status(401).json({message:"No token provided"});let d=a.split(" ")[1];console.log("Token received, verifying...");try{o=s().verify(d,i),console.log("Token verified, user ID:",o.id)}catch(e){if(console.error("Token verification error:",e),e instanceof s().TokenExpiredError)return r.status(401).json({message:"Token expired"});return r.status(401).json({message:"Invalid token"})}let u=await t.n.findById(o.id).select("-password");if(!u)return console.log("User not found for ID:",o.id),r.status(401).json({message:"User not found"});console.log("User found:",u._id),e.user=u,console.log("=== END: Auth Middleware ===\n");try{await n()}catch(e){return console.error("Error in route handler:",e),r.status(500).json({message:"Internal server error",error:e instanceof Error?e.message:"Unknown error"})}}catch(e){return console.error("Auth middleware error:",e),r.status(500).json({message:"Authentication failed",error:e instanceof Error?e.message:"Unknown error"})}}function d(e){return s().sign({id:e},i,{expiresIn:"7d"})}},8208:(e,r,n)=>{n.d(r,{n:()=>d});var o=n(1185),s=n.n(o);let t=require("bcryptjs");var i=n.n(t);let a=new(s()).Schema({email:{type:String,required:!0,unique:!0,trim:!0,lowercase:!0},username:{type:String,required:!0,unique:!0,trim:!0,lowercase:!0,minlength:3,maxlength:30,match:[/^[a-zA-Z0-9_]+$/,"Username can only contain letters, numbers and underscores"]},password:{type:String,required:!0,minlength:6},name:{type:String,required:!0,trim:!0},friends:[{type:s().Schema.Types.ObjectId,ref:"User"}],friendRequests:[{from:{type:s().Schema.Types.ObjectId,ref:"User",required:!0},createdAt:{type:Date,default:Date.now}}],lastCheckIn:{type:Date,default:null}},{timestamps:!0});a.pre("save",async function(e){if(!this.isModified("password"))return e();try{let r=await i().genSalt(10);this.password=await i().hash(this.password,r),e()}catch(r){e(r)}}),a.methods.comparePassword=async function(e){return i().compare(e,this.password)};let d=s().models.User||s().model("User",a)},7153:(e,r)=>{var n;Object.defineProperty(r,"x",{enumerable:!0,get:function(){return n}}),function(e){e.PAGES="PAGES",e.PAGES_API="PAGES_API",e.APP_PAGE="APP_PAGE",e.APP_ROUTE="APP_ROUTE"}(n||(n={}))},1802:(e,r,n)=>{e.exports=n(145)}};var r=require("../../../webpack-api-runtime.js");r.C(e);var n=r(r.s=6651);module.exports=n})();